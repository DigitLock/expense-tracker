// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: exchange_rates.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createExchangeRate = `-- name: CreateExchangeRate :one
INSERT INTO exchange_rates (
    id, from_currency, to_currency, rate, date
) VALUES (
             $1, $2, $3, $4, $5
         )
RETURNING id, from_currency, to_currency, rate, date, source, created_at
`

type CreateExchangeRateParams struct {
	ID           uuid.UUID       `json:"id"`
	FromCurrency string          `json:"from_currency"`
	ToCurrency   string          `json:"to_currency"`
	Rate         decimal.Decimal `json:"rate"`
	Date         pgtype.Date     `json:"date"`
}

func (q *Queries) CreateExchangeRate(ctx context.Context, arg CreateExchangeRateParams) (ExchangeRate, error) {
	row := q.db.QueryRow(ctx, createExchangeRate,
		arg.ID,
		arg.FromCurrency,
		arg.ToCurrency,
		arg.Rate,
		arg.Date,
	)
	var i ExchangeRate
	err := row.Scan(
		&i.ID,
		&i.FromCurrency,
		&i.ToCurrency,
		&i.Rate,
		&i.Date,
		&i.Source,
		&i.CreatedAt,
	)
	return i, err
}

const getExchangeRate = `-- name: GetExchangeRate :one
SELECT id, from_currency, to_currency, rate, date, source, created_at FROM exchange_rates
WHERE from_currency = $1
  AND to_currency = $2
  AND date = $3
`

type GetExchangeRateParams struct {
	FromCurrency string      `json:"from_currency"`
	ToCurrency   string      `json:"to_currency"`
	Date         pgtype.Date `json:"date"`
}

func (q *Queries) GetExchangeRate(ctx context.Context, arg GetExchangeRateParams) (ExchangeRate, error) {
	row := q.db.QueryRow(ctx, getExchangeRate, arg.FromCurrency, arg.ToCurrency, arg.Date)
	var i ExchangeRate
	err := row.Scan(
		&i.ID,
		&i.FromCurrency,
		&i.ToCurrency,
		&i.Rate,
		&i.Date,
		&i.Source,
		&i.CreatedAt,
	)
	return i, err
}

const getLatestExchangeRate = `-- name: GetLatestExchangeRate :one
SELECT id, from_currency, to_currency, rate, date, source, created_at FROM exchange_rates
WHERE from_currency = $1
  AND to_currency = $2
  AND date <= $3
ORDER BY date DESC
LIMIT 1
`

type GetLatestExchangeRateParams struct {
	FromCurrency string      `json:"from_currency"`
	ToCurrency   string      `json:"to_currency"`
	Date         pgtype.Date `json:"date"`
}

func (q *Queries) GetLatestExchangeRate(ctx context.Context, arg GetLatestExchangeRateParams) (ExchangeRate, error) {
	row := q.db.QueryRow(ctx, getLatestExchangeRate, arg.FromCurrency, arg.ToCurrency, arg.Date)
	var i ExchangeRate
	err := row.Scan(
		&i.ID,
		&i.FromCurrency,
		&i.ToCurrency,
		&i.Rate,
		&i.Date,
		&i.Source,
		&i.CreatedAt,
	)
	return i, err
}

const listExchangeRatesByDate = `-- name: ListExchangeRatesByDate :many
SELECT id, from_currency, to_currency, rate, date, source, created_at FROM exchange_rates
WHERE date = $1
ORDER BY from_currency, to_currency
`

func (q *Queries) ListExchangeRatesByDate(ctx context.Context, date pgtype.Date) ([]ExchangeRate, error) {
	rows, err := q.db.Query(ctx, listExchangeRatesByDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExchangeRate{}
	for rows.Next() {
		var i ExchangeRate
		if err := rows.Scan(
			&i.ID,
			&i.FromCurrency,
			&i.ToCurrency,
			&i.Rate,
			&i.Date,
			&i.Source,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExchangeRatesHistory = `-- name: ListExchangeRatesHistory :many
SELECT id, from_currency, to_currency, rate, date, source, created_at FROM exchange_rates
WHERE from_currency = $1
  AND to_currency = $2
  AND date >= $3
  AND date <= $4
ORDER BY date DESC
`

type ListExchangeRatesHistoryParams struct {
	FromCurrency string      `json:"from_currency"`
	ToCurrency   string      `json:"to_currency"`
	Date         pgtype.Date `json:"date"`
	Date_2       pgtype.Date `json:"date_2"`
}

func (q *Queries) ListExchangeRatesHistory(ctx context.Context, arg ListExchangeRatesHistoryParams) ([]ExchangeRate, error) {
	rows, err := q.db.Query(ctx, listExchangeRatesHistory,
		arg.FromCurrency,
		arg.ToCurrency,
		arg.Date,
		arg.Date_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExchangeRate{}
	for rows.Next() {
		var i ExchangeRate
		if err := rows.Scan(
			&i.ID,
			&i.FromCurrency,
			&i.ToCurrency,
			&i.Rate,
			&i.Date,
			&i.Source,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertExchangeRate = `-- name: UpsertExchangeRate :one
INSERT INTO exchange_rates (
    id, from_currency, to_currency, rate, date
) VALUES (
             $1, $2, $3, $4, $5
         )
ON CONFLICT (from_currency, to_currency, date)
    DO UPDATE SET rate = EXCLUDED.rate
RETURNING id, from_currency, to_currency, rate, date, source, created_at
`

type UpsertExchangeRateParams struct {
	ID           uuid.UUID       `json:"id"`
	FromCurrency string          `json:"from_currency"`
	ToCurrency   string          `json:"to_currency"`
	Rate         decimal.Decimal `json:"rate"`
	Date         pgtype.Date     `json:"date"`
}

func (q *Queries) UpsertExchangeRate(ctx context.Context, arg UpsertExchangeRateParams) (ExchangeRate, error) {
	row := q.db.QueryRow(ctx, upsertExchangeRate,
		arg.ID,
		arg.FromCurrency,
		arg.ToCurrency,
		arg.Rate,
		arg.Date,
	)
	var i ExchangeRate
	err := row.Scan(
		&i.ID,
		&i.FromCurrency,
		&i.ToCurrency,
		&i.Rate,
		&i.Date,
		&i.Source,
		&i.CreatedAt,
	)
	return i, err
}
